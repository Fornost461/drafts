#!/bin/sh

PROG_NAME="$(basename "${0}")"
SUCCESS=0
WRONG_USAGE=1
INTERRUPTION=2

trap 'exit "${INTERRUPTION}"' HUP INT QUIT TERM

# default values
step=1
unit='m'
alarm='/home/val/mnt/Data/Downloads/music/genres/ambient/new age/Gladiator Theme • Now We Are Free • Hans Zimmer & Lisa Gerrard (NBE-uBgtINg).webm'
total_time=''
verbose=true

_usage()
{
    cat <<-EOF

	${PROG_NAME} [OPTION]... [total_time] [unit]
	Wait approximately ‘total_time’ ‘unit’s of time, regularly displaying
	the program's state.

	<total_time>
	    Number of units of time to wait (must be an integer).
	    If unspecified, wait indefinitely.
	<unit> (default: '${unit}')
	    May be 's', 'm', 'h' or 'd'. Wait ‘total_time’ ‘unit’s of time.
	    A message shows up every ‘step’ ‘unit’s.
	-s <step> (default: ${step})
	    A message shows up every ‘step’ ‘unit’.
	-a <alarm> (default: '${alarm}')
	    Set the path of the file to launch with VLC after the waiting time.
	    Enable alarm.
	-m
	    Disable alarm.
	-q
	    Attempt to make output less verbose.
	-h, --help
	    Display this help and exit.

	Exit status:
	    ${SUCCESS}    success
	    ${WRONG_USAGE}    wrong usage
	    ${INTERRUPTION}    external interruption

	EOF
}

# process arguments
while [ "${#}" -gt 0 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        (s|m|h|d)
            unit="${arg}"
            ;;
        (-a)
            if [ -f "${1}" ]; then
                alarm="${1}"
                shift
            else
                echo "Bad usage: option -a necessitates an argument which should be the path of a regular file. (Received: “${1}”.)" >&2
                _usage
                exit "${WRONG_USAGE}"
            fi
            ;;
        (-m)
            alarm=''
            ;;
        (-s)
            case "${1}" in
                (''|*[!0-9]*)
                    # warn about bad value below
                    step=''
                    ;;
                (*)
                    if [ "${1}" -gt 0 ]; then
                        step="${1}"
                    else
                        # warn about bad value below
                        step=''
                    fi
                    ;;
            esac
            if [ -z "${step}" ]; then
                echo "Bad usage: option -s necessitates an argument which should be a positive integer. (Received: “${1}”.)" >&2
                _usage
                exit "${WRONG_USAGE}"
            fi
            shift
            ;;
        (-q)
            verbose=false
            ;;
        (-h|--help)
            _usage
            exit "${SUCCESS}"
            ;;
        (--)    # end of options
            break
            ;;
        (-?|--*)    # unknown option
            echo "Invalid option: “${arg}”." >&2
        _usage
            exit "${WRONG_USAGE}"
            ;;
        (-??*)  # several short options
            while [ "${arg}" != '-' ]   # parse
            do
                new_arg="${arg%?}"  # remove last option
                option="${arg##${new_arg}}" # read it
                # forget dashes and add option to the list of single options to process
                [ "${option}" = '-' ] || set -- "-${option}" "${@}"
                arg="${new_arg}"
            done
            ;;
        ('')    # ignore empty arguments
            ;;
        (*[!0-9]*) # not an option
            echo "Invalid argument: “${arg}”." >&2
        _usage
            exit "${WRONG_USAGE}"
            ;;
        (*) # integer
            total_time="$((arg))"
            ;;
    esac
done

# process any remaining arguments
while [ "${#}" -gt 0 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        (s|m|h|d)
            unit="${arg}"
            ;;
        ('')    # ignore empty arguments
            ;;
        (*[!0-9]*) # not an option
            echo "Invalid argument: “${arg}”." >&2
            _usage
            exit "${WRONG_USAGE}"
            ;;
        (*) # integer
            total_time="$((arg))"
            ;;
    esac
done

if [ -z "${total_time}" ]; then
    i=0
    fac=1
    print_steps=true
else
    i="${total_time}"
    fac=-1
    print_steps="${verbose}"
fi

if "${verbose}"; then
    date
    echo "${i}${unit}"
fi

i="$((i+fac*step))"
# launch chronometer
while [ "${i}" -ge 0 ]
do
    sleep "${step}${unit}"
    "${print_steps}" && echo "${i}${unit}"
    i="$((i+fac*step))"
done

if [ -n "${alarm}" ]; then
    # launch alarm
    vlc "${alarm}" >/dev/null 2>&1 & disown
fi
"${verbose}" && date
