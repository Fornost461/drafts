#!/bin/sh

# wait_until_quit [OPTION]... <process_keyword>
# Wait for the processes matching ‘process_keyword’ to quit.

_usage()
{
    cat <<-EOF

	wait_until_quit [OPTION]... <process_keyword>
	Wait for the processes matching <process_keyword> to quit. (May behave weirdly due to self-referentiality issues.)

	<process_keyword>
	    In the output returned by ‘ps ax’, <process_keyword> must identify the lines corresponding to the desired processes.
	-l <limit> (default: 0)
	    Number of matched processes to ignore: even if they still match <process_keyword> when the desired processes have quit, return with success.
	-m <max> (default: 0)
	    Maximal amount of checks to perform. If <max> is not specified or is 0, do not limit the number of checks.
	-p <period> (default: 3)
	    number of seconds between the checks made to determine if the processes have quit.
	-q
	    Print less output.
	-h, --help
	    display this help and exit

	Exit status:
	    0    success
	    1    maximal amount of checks exceeded
	    2    user error

	EOF
}

PROG_NAME='wait_until_quit'

MAX_EXCEEDED=1
USER_ERROR=2

_wrongUsage()
{
    if [ "${#}" -eq 0 ]; then
        echo "${PROG_NAME}: error: bad usage." >&2
    else
        printf '%s' '${PROG_NAME}: error: bad usage: '
        # print each argument on a new line
        printf '%s\n' "${@}" >&2
    fi
    _usage
    exit "${USER_ERROR}"
}

_countProcesses()
{
    ps ax | grep -ic "${process_keyword}"
}

_display()
{
    ps ax | grep -i "${process_keyword}"
}

if [ "${#}" -eq 0 ]; then
    _usage
    exit
fi

limit=0
max=0
period=3
verbose=true

# handle arguments
while [ "${#}" -ge 2 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        '')
            ;;
        -h|--help)
            _usage
            exit
            ;;
        -l)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -l should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    limit="${1}"
            esac
            shift
            ;;
        -m)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -m should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    max="${1}"
            esac
            shift
            ;;
        -p)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -p should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    period="${1}"
            esac
            shift
            ;;
        -q)
            verbose=false
            ;;
        *)
            _wrongUsage " invalid argument: “${arg}”."
            ;;
    esac
done

# take into account the grep process generated by the current script
let 'limit++'

# wait for processes to quit
wait=true
i=0
count="$(_countProcesses)"
while [ "${count}" -gt "${limit}" ]
do
    let 'i++'
    if [ "${max}" -gt 0 ] && [ "${i}" -gt "${max}" ]; then
        "${verbose}" && echo "${PROG_NAME}: maximal amount of checks exceeded." >&2
        exit "${MAX_EXCEEDED}"
    fi
    sleep "${period}"
    "${verbose}" && _display
    count="$(_countProcesses)"
done

"${verbose}" && echo "${PROG_NAME}: success!"
