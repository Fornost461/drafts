#!/bin/sh

# wait_until_quit [OPTION]... <process_keyword>
# Wait for the processes matching ‘process_keyword’ to quit.

_usage()
{
    cat <<-EOF

	wait_until_quit [OPTION]... <process_keyword>
	Wait for the processes matching <process_keyword> to quit. (May behave weirdly due to self-referentiality issues.)

	<process_keyword>
	    in the output returned by ‘ps ax’, <process_keyword> must identify the lines corresponding to the desired processes.
	-l <limit>
	    (default: 0) number of matched processes to ignore: even if they still match <process_keyword> when the desired processes have quit, return with success.
	-m <max>
	    maximal amount of checks to perform.
        If <max> is not specified or is 0, do not limit the number of checks.
	-p <period>
	    number of seconds between instances of checking if the processes have quit (default: 3).
	-h, --help
	    display this help and exit

	Exit status:
	    0    success
	    1    maximal amount of checks exceeded
	    2    user error

	EOF
}

MAX_EXCEEDED=1
USER_ERROR=2

_wrongUsage()
{
    if [ "${#}" -eq 0 ]; then
        echo 'Error: bad usage.' >&2
    else
        printf '%s' 'Error: bad usage: '
        # print each argument on a new line
        printf '%s\n' "${@}" >&2
    fi
    _usage
    exit "${USER_ERROR}"
}

_countProcesses()
{
    ps ax | grep -ic "${process_keyword}"
}

period=3
max=0
limit=0

# handle arguments
while [ "${#}" -ge 2 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        '')
            ;;
        -h|--help)
            _usage
            exit
            ;;
        -l)
            if [ "${#}" -ge 1 ]; then
                case "${1}" in
                    ''|*[!0-9]*)
                        _wrongUsage "argument for option -l should be an unsigned integer (received: “${1}”)."
                        ;;
                    *)
                        limit="${1}"
                esac
                shift
            else
                _wrongUsage "option -l takes an argument."
            fi
            ;;
        -m)
            if [ "${#}" -ge 1 ]; then
                case "${1}" in
                    ''|*[!0-9]*)
                        _wrongUsage "argument for option -m should be an unsigned integer (received: “${1}”)."
                        ;;
                    *)
                        max="${1}"
                esac
                shift
            else
                _wrongUsage "option -l takes an argument."
            fi
            ;;
        -p)
            if [ "${#}" -ge 1 ]; then
                case "${1}" in
                    ''|*[!0-9]*)
                        _wrongUsage "argument for option -p should be an unsigned integer (received: “${1}”)."
                        ;;
                    *)
                        period="${1}"
                esac
                shift
            else
                _wrongUsage "option -l takes an argument."
            fi
            ;;
        *)
            _wrongUsage " invalid argument: “${arg}”."
            ;;
    esac
done
process_keyword="${1}"

# take into account the grep process generated by the current script
let 'limit++'

# wait for processes to quit
wait=true
i=0
while [ "$(_countProcesses)" -gt "${limit}" ]
do
    if [ "${max}" -gt 0 ] && [ "${i}" -gt "${max}" ]; then
        exit "${MAX_EXCEEDED}"
    fi
    sleep "${period}"
    let 'i++'
done
