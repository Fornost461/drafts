#!/bin/sh

# wait_until_quit [OPTION]... <process_keyword>
# Wait for the processes matching ‘process_keyword’ to quit.

PROG_NAME="$(basename "${0}")"

SUCCESS=0
MAX_EXCEEDED=1
WRONG_USAGE=2
INTERRUPTION=3

trap 'exit "${INTERRUPTION}"' HUP INT QUIT TERM

limit=3
max=0
period=3
verbose=true

_usage()
{
    cat <<-EOF

	${PROG_NAME} [OPTION]... <process_keyword>
	Wait for the processes matching <process_keyword> to quit.

	<process_keyword>
	    In the output returned by ‘ps ax’, <process_keyword> is used to
	    identify the lines corresponding to the desired processes. It must
	    not start with a hyphen.
	-l <limit> (default: ${limit})
	    Number of matched processes to ignore: even if they still match
	    <process_keyword> when the desired processes have quit, return
	    with success. (The script itself and two processes generated by it
	    are supposed to match, the default is therefore set to ${limit}
	    instead of 0.)
	-m <max> (default: ${max})
	    Maximal amount of checks to perform. If <max> is not specified or
	    is 0, do not limit the number of checks.
	-p <period> (default: ${period})
	    Number of seconds between the checks made to determine if the
	    processes have quit.
	-q
	    Print less output.
	-h, --help
	    Display this help and exit.

	Exit status:
	    ${SUCCESS}    success
	    ${MAX_EXCEEDED}    maximal amount of checks exceeded
	    ${WRONG_USAGE}    wrong usage
	    ${INTERRUPTION}    external interruption

	EOF
}

_helpAndExit()
{
    _usage
    exit "${1:-"${SUCCESS}"}"
}

_wrongUsage()
{
    if [ "${#}" -eq 0 ]; then
        echo "${PROG_NAME}: error: bad usage." >&2
    else
        printf '%s: error: bad usage: ' "${PROG_NAME}"
        # print each argument on a new line
        printf '%s\n' "${@}" >&2
    fi
    _helpAndExit "${WRONG_USAGE}"
}

_actualize()
{
    local matches
    matches="$(ps ax | grep "${process_keyword}")"
    # (to compensate for a missing new line, add one at the end of the block of text contained in ${matches})
    count="$(printf '%s\n' "${matches}" | wc -l)"
    "${verbose}" && printf '%s\n' "${count}" "${matches}"
}

# handle arguments
while [ "${#}" -ge 1 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        '')
            ;;
        -h|--help)
            _helpAndExit
            ;;
        -l)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -l should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    limit="${1}"
            esac
            shift
            ;;
        -m)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -m should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    max="${1}"
            esac
            shift
            ;;
        -p)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -p should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    period="${1}"
            esac
            shift
            ;;
        -q)
            verbose=false
            ;;
        --)
            if [ "${#}" -eq 1 ]; then
                break
            else
                _wrongUsage "end of options (double hyphen) found whereas ${#} arguments remain instead of just one. Arguments:" "${@}"
            fi
            ;;
        -?|--*) # unknown option
            _wrongUsage "invalid option: ${arg}" >&2
            _usage
            exit 1
            ;;
        -??*)   # several short options
            while [ "${arg}" != '-' ]   # parse
            do
                new_arg="${arg%?}"  # remove last option
                option="${arg##${new_arg}}" # read it
                # forget dashes and add option to the list of single options to process
                [ "${option}" = '-' ] || set -- "-${option}" "${@}"
                arg="${new_arg}"
            done
            ;;
        *)
            if [ "${#}" -eq 0 ]; then
                process_keyword="${arg}"
            else
                _wrongUsage " invalid argument: “${arg}”."
            fi
            ;;
    esac
done

if [ -z "${process_keyword}" ]; then
    _wrongUsage "argument not found: <process_keyword>."
fi

# wait for processes to quit
wait=true
_actualize
i=1
while [ "${count}" -gt "${limit}" ]
do
    if [ "${max}" -gt 0 ] && [ "${i}" -gt "${max}" ]; then
        "${verbose}" && echo "${PROG_NAME}: maximal amount of checks exceeded." >&2
        exit "${MAX_EXCEEDED}"
    fi
    sleep "${period}"
    _actualize
    i="$((i+1))"
done

"${verbose}" && echo "${PROG_NAME}: success!"
"${verbose}" && [ "${count}" -ne "${limit}" ] && printf '%s\n' "(debug information: ${count} <= ${limit})"
exit "${SUCCESS}"
