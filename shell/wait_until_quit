#!/bin/sh

# wait_until_quit [OPTION]... <process_keyword>
# Wait for the processes matching ‘process_keyword’ to quit.

PROG_NAME="$(basename "${0}")"

SUCCESS=0
MAX_EXCEEDED=1
USER_ERROR=2
INTERRUPTION=3

trap 'exit "${INTERRUPTION}"' HUP INT QUIT TERM

_usage()
{
    cat <<-EOF

	${PROG_NAME} [OPTION]... <process_keyword>
	Wait for the processes matching <process_keyword> to quit.

	<process_keyword>
	    In the output returned by ‘ps ax’, <process_keyword> is used to
	    identify the lines corresponding to the desired processes. It must not
	    start with a hyphen.
	-l <limit> (default: 0)
	    Number of matched processes to ignore: even if they still match
	    <process_keyword> when the desired processes have quit, return with
	    success. (Technically, the script ignores two more processes than
	    <limit>, because the script itself and a process it generates are
	    supposed to match too.)
	-m <max> (default: 0)
	    Maximal amount of checks to perform. If <max> is not specified or is
	    0, do not limit the number of checks.
	-p <period> (default: 3)
	    number of seconds between the checks made to determine if the
	    processes have quit.
	-q
	    Print less output.
	-h, --help
	    display this help and exit

	Exit status:
	    ${SUCCESS}    success
	    ${MAX_EXCEEDED}    maximal amount of checks exceeded
	    ${USER_ERROR}    user error
	    ${INTERRUPTION}    external interruption

	EOF
}

_helpAndExit()
{
    _usage
    exit "${1:-"${SUCCESS}"}"
}

_wrongUsage()
{
    if [ "${#}" -eq 0 ]; then
        echo "${PROG_NAME}: error: bad usage." >&2
    else
        printf '%s: error: bad usage: ' "${PROG_NAME}"
        # print each argument on a new line
        printf '%s\n' "${@}" >&2
    fi
    _helpAndExit "${USER_ERROR}"
}

_countProcesses()
{
    ps ax | grep -c "${process_keyword}"
}

_display()
{
    ps ax | grep "${process_keyword}"
}

limit=0
max=0
period=3
verbose=true

# handle arguments
while [ "${#}" -ge 1 ]
do
    arg="${1}"
    shift
    case "${arg}" in
        '')
            ;;
        -h|--help)
            _helpAndExit
            ;;
        -l)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -l should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    limit="${1}"
            esac
            shift
            ;;
        -m)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -m should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    max="${1}"
            esac
            shift
            ;;
        -p)
            case "${1}" in
                ''|*[!0-9]*)
                    _wrongUsage "argument for option -p should be an unsigned integer (received: “${1}”)."
                    ;;
                *)
                    period="${1}"
            esac
            shift
            ;;
        -q)
            verbose=false
            ;;
        --)
            if [ "${#}" -eq 1 ]; then
                break
            else
                _wrongUsage "end of options (double hyphen) found whereas ${#} arguments remain instead of just one. Arguments:" "${@}"
            fi
            ;;
        -?|--*) # unknown option
            _wrongUsage "invalid option: ${arg}" >&2
            _usage
            exit 1
            ;;
        -??*)   # several short options
            while [ "${arg}" != '-' ]   # parse
            do
                new_arg="${arg%?}"  # remove last option
                option="${arg##${new_arg}}" # read it
                # forget dashes and add option to the list of single options to process
                [ "${option}" = '-' ] || set -- "-${option}" "${@}"
                arg="${new_arg}"
            done
            ;;
        *)
            if [ "${#}" -eq 0 ]; then
                process_keyword="${arg}"
            else
                _wrongUsage " invalid argument: “${arg}”."
            fi
            ;;
    esac
done

if [ -z "${process_keyword}" ]; then
    _wrongUsage "argument not found: <process_keyword>."
fi

# take into account the current script and the grep process it generates
limit="$((limit+2))"

# wait for processes to quit
wait=true
i=0
count="$(_countProcesses)"
while [ "${count}" -gt "${limit}" ]
do
    i="$((i+1))"
    if [ "${max}" -gt 0 ] && [ "${i}" -gt "${max}" ]; then
        "${verbose}" && echo "${PROG_NAME}: maximal amount of checks exceeded." >&2
        exit "${MAX_EXCEEDED}"
    fi
    "${verbose}" && _display
    count="$(_countProcesses)"
    sleep "${period}"
done

"${verbose}" && echo "${PROG_NAME}: success!"
