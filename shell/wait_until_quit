#!/bin/sh

# wait_until_quit [OPTION]... <process_keyword>
# Wait for the processes matching ‘process_keyword’ to quit.

_usage()
{
    cat <<-EOF

	wait_until_quit [OPTION]... <process_keyword>
	Wait for the processes matching <process_keyword> to quit. (May behave weirdly due to self-referentiality issues.)

	<process_keyword>: in the output returned by ‘ps ax’, <process_keyword> must identify the lines corresponding to the desired processes.
	-p <period>: number of seconds between instances of checking if the processes have quit (default: 3).
	-m <max>: maximal amount of checks to perform. If <max> is not specified or is 0, do not limit the number of checks.
	-l <limit>: (default: 0) number of processes which should still match <process_keyword> when the desired processes have quit.
    --: indicates the end of options. The next argument, if any, is interpreted as <process_keyword>. (Useful if <process_keyword> starts with a hyphen.)

	EOF
}

_wrongUsage()
{
    if [ "${#}" -eq 0 ]; then
        echo 'Error: bad usage.' >&2
    else
        # print each argument on a new line
        printf '%s\n' "${@}" >&2
    fi
    _usage
    exit 2
}

_countProcesses()
{
    ps ax | grep -ic "${process_keyword}"
}

period=3
max=0
limit=0

# handle arguments
while [ "${#}" -ge 1 ]
do
    case "${1}" in
        -p)
            case "${2}" in
                ''|*[!0-9]*)
                    _wrongUsage "Error: bad usage: argument for option -p should be a positive integer (received: “${2}”)."
                    ;;
                *)
                    period="${2}"
            esac
            shift 2
            ;;
        -h|--help)
            _usage
            exit
            ;;
        *)
            _wrongUsage
            ;;
    esac
done

# wait for processes to quit
wait=true
i=0
while [ "$(_countProcesses)" -gt "${limit}" ]
do
    if [ "${i}" -gt "${max}" ]; then
        break
    fi
    sleep "${period}"
    let 'i++'
done
